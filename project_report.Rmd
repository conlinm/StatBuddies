---
title: "NHANES Data Analysis Project"
author: "STAT 420, Summer 2023, Preeti Agrawal, Thimira Bandara, Michael Conlin, Constatin Kappel"
date: "August 4, 2023"
output:
  html_document: 
    theme: readable
    toc: yes
  pdf_document: default
urlcolor: cyan
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
options(scipen = 1, digits = 4, width = 80, fig.align = "center")
library(knitr)
```


# Title

## Introduction

Obesity is an endemic health issue common to many industrialized nations in the world. It is known that obesity is related to cardiovascular disease (high blood pressure, heart attack, stroke), type II diabetes, sleep apnea, metabolic syndrome, fatty liver disease and cancer [CDC on obesity](https://www.cdc.gov/healthyweight/effects/index.html). According to the World Health Organization, [WHO](https://www.who.int/news-room/fact-sheets/detail/obesity-and-overweight), obesity has nearly tripled between 1975 and 2021, in a time frame of less than two generations. Obesity can be measured by the BMI, is therefore a relevant health issue. The threshold of calling someone obese is a BMI $\geq$ 30.   

Our personal interest in obesity is comes from the fact that two members of this team have a background in biochemistry and medicine, respectively, and that obesity still represents a health issue which everyone knows and can observe in everyday life. So, while there is a bio-medical relevance of the topic, the concept of BMI or the phenomenon of obesity do not require everyone to have a deep domain-specific knowledge. In fact, none of us directly worked scientifically with obesity before and thus we saw it as a new and challenging topic to work on. 

We are using the "the non-institutionalized civilian resident population of the United States" (NHANES) dataset. It has been published by the "American National Health and Nutrition Examination surveys" since the 1960s. The full data thus covers the relevant time frame which saw the drastic increase in obesity as reported by the WHO. The full data can be obtained from [CDC.gov](http://www.cdc.gov/nchs/nhanes.htm). 
We are using a subset of NHANES which is easily accessible through the R library `NHANES`. It comprises a subset of 10,000 rows and covers a survey period between 2009 and 2012. While not comprehensive it should give us enough material to build a model, select different predictors and reason about its predictions. Our goal is to build an interpretable model which identifies and quantifies the influence of several physical and life style-related predictors on body weight, specifically the BMI.

In order to build an interpretable model we need to be mindful with non-linear data transformations, high-order interactions and also need to keep variance inflation under control. The task is made challenging by a large number of missing values. If we simply omit all `NA`s using `na.omit()`, which discards all rows with any missing value, we will reduce the total information from 10,000 observations to less than 1%. 

Our strategy outline for approaching this project is as follows:

1. Variable, that is, predictor selection using a combination of semantic grouping (some variables convey similar information) and collinearity (visually, through `pairs()` plots). 
2. With a subset of predictors, which we call `nhanes_select`, we then approach the problem of missing data by using multivariate imputation by chained equations [MICE](https://doi.org/10.18637/jss.v045.i03) using the `mice` library by Buuren and Groothuls-Outhoorn (2011). 
3. After omitting all `NA`s, and with 5 versions of the imputed data, we build our first additive model to check parameter estimates, p-values, significance of regression as well as testing LINE assumptions.
4. Next we apply a Box-Cox transformation to BMI and use different search procedures, backwards, forwards, and stepwise to search for models and select predictors.
5. After this we check which variables are correlated with BMI to further investigate possible interaction terms, and determine if there are other variables we could consider dropping.
6. We then consider if our models of interest could benefit from any data transformations.
7. Finally, we perform outlier assessment and diagnostics on our models of interest to evaluate them and explain which model(s) we prefer.  

## Methods

### Data Import

```{r}
if (!require(NHANES)) {
  install.packages("NHANES", quiet = TRUE)  
}
library(NHANES, quiet = TRUE)

```

### Initial Variable Selection

#### Rule out variables by reasoning or by exploratory analysis

We have chosen `BMI` (Body mass index (weight/height² in $[\frac{kg}{m²}]$) as our response variable. In NHANES, this data is reported for participants aged 2 years or older, so we will focus on those participants for our analysis. Provided below are all the variables in NHANES, along with our response variable `BMI`.

```{r}
sort(names(NHANES)) # alphabetic order
```

We will add all omitted variables to a dataframe `df_exclude`. The variables we would like to use as predictors will be kept in a dataframe `df_keep`. The following is our reasoning for ruling out or keeping certain variables as predictors:

1. Some predictors can be ruled out right away. Our response variable is `BMI`, so we should not use body `Weight` or `Height` as predictors, because `BMI` is calculated by dividing the `Weight` by `Height`.  

2. The next group of predictors seem very closely related either by name or logic deduction, for example, age related variables such as `Age`, `AgeDecade`, `AgeMonths`. Let's quickly double-check if they are linearly related: 

```{r, fig.asp={1}}
pairs(subset(NHANES, select = c('Age', 'AgeDecade', 'AgeMonths',
                                'AgeFirstMarij', 'AgeRegMarij')))
```

`Age`, `AgeDecade` and `AgeMonth` are clearly collinear, so we will only keep `Age`. Likewise, both variables for Marijuana use appear collinear, so we keep only one, say `AgeRegMarij` and we may decide to drop it later if it is not useful. 

3. Now let's check for collinearity between different blood pressure related variables: 

```{r, fig.asp=1}
to_test = c("BPDia1", "BPDia2", "BPDia3", "BPDiaAve", "BPSys1", "BPSys2", "BPSys3", "BPSysAve" )
pairs(subset(NHANES, select=to_test))
```

The blood pressure variables fall into two groups: diastolic and systolic blood pressure readings. We would expect there to be strongly collinearity within each group, which is the case. So, we only keep the average in each group `BPDiaAve` and `BPSysAve`.

#### Refer to the Appendix for the `pairs()` plots assessment of the following variables' collinearity:

4. Let's check all variables related to alcohol: We again performed a `pairs()` plot to visualize possible collinearity, and this graph is in the Appendix. Collinearity is not as clear in this case, but we believe one predictor related to alcohol consumption may be sufficient. We will keep `AlcoholYear`. 

5. Let's now investigate the collinearity of other drug-related variables: Most of these predictors are categorical, so collinearity cannot be seen, except for `SmokeAge` and `AgeRegMarij`. The latter makes sense as this drug is usually consumed via smoking. We can thus use one as a proxy for the other. (Note: `AgeRegMarij` was in the age related group above as well and we kept it). Let's keep `SmokeNow` and `HardDrugs` as proxies for drug abuse and its potential effect on BMI. 

6. Next, let's investigate a few life-style variables related to being physically active or the opposite thereof, screen time: Due to the nature of these variables being categorical, a clear picture of collinearity is not observable. Let's keep half of these parameters for now, which are the ones with a bit denser levels, `PhysActiveDays`, `TVHrsDay`, `CompHrsDay`. 

7. Now let's look into some other health related variables, such as cholesterol and diabetes related predictors:
`DirectChol` and `TotChol` appear to be collinear, let's keep `TotChol`. Out of the diabetes related ones, we keep `Diabetes`.

8. Let's analyze more health related variables, such as those related to urine volume and flow below:
Urine volume and urine flow appear collinear. Moreover, there might be collinearity between the first and second urine measurement, respectively. Let's keep `UrineVol1` for now. 

9. Next we analyze a somewhat heterogenic group of variables related to health or mental health. For example, somebody who is depressed might show little interest in doing things. Again, collinearity is not easy to spot in categorical variables. Let's pick `LittleInterest` as a mild form of mental health issue which might lead to little physical activity and obesity, and `HealthGen` as a general health rating. 

10. We decide to keep `Poverty` which is a ratio of family income to poverty guidelines, and drop `HHIncomeMid` and `HHIncome`, as they both capture similar information to what the `Poverty` variable captures. Similarly, we choose to keep `Race1` instead of `Race3` as they both capture similar information, and `Race1` has more data compared to `Race3`.

11. Finally, let's add `Poverty`, `SleepHrsNight`, `Gender`, `Race1`, `Education`, and `MartialStatus` as we believe they can have an effect on BMI, and we do not suspect collinearity.  

```{r }
#Setting up the dataframes with the variables we will be excluding and keeping for model building

df_exclude = data.frame(predictor = c('Weight', 'Height', 'Age1stBaby', 'AgeDecade', 'AgeMonth',
                                      'AgeRegMarij', 'Alcohol12PlusYr', 'AlcoholDay', 'Smoke100',
                                      'SmokeAge', 'Marijuana', 'RegularMarij', "BPDia1", "BPDia2",
                                      "BPDia3", "BPSys1", "BPSys2", "BPSys3", 'PhysActive', 
                                      'TVHrsDayChild', 'CompHrsDayChild', 'DirectChol', 
                                      'DiabetesAge', "UrineFlow1", "UrineVol2", "UrineFlow2", 
                                      "DaysPhysHlthBad", "DaysMentHlthBad", "Depressed", "Race3",
                                      "nPregnancies"), 
reason_to_omit = c('linear dependence with BMI','linear dependence with BMI', 'specific by Gender',
                   'collinear with Age', 'collinear with Age', 
                   'redundant with Marijuana', 'more sparse than AlcoholYear', 'redundant with
                   AlcoholYear', 'redundant with SmokeNow', 'collinear with AgeRegMarij', 
                   'redundant with AgeRegMarij, the two might be swapped', 'redundant with Marijuana',
                   'collinear with other blood pressure predictors', 'collinear with other blood 
                   pressure predictors', 'collinear with other blood pressure predictors', 'collinear
                   with other blood pressure predictors', 'collinear with other blood pressure 
                   predictors', 'collinear with other blood pressure predictors', 'Redundant with
                   PhysActiveDays', 'redundant with TVHrsDay', 'redundant with CompHrsDay', 'collinear
                   with TotChol', 'redundant with Diabetes', 'collinear with UrineVol1', 'collinear 
                   with UrineVol1','collinear with UrineVol1', 'redundant with HealthGen', 'redundant
                   with HealthGen','redundant with HealthGen', 'redundant with Race1', 'specific by 
                   Gender'))

#Note: 'SurveyYr' is not a predictor, we will be filtering data by SurveyYr later,after which we 
#will remove SurveyYr from the predictor list.
df_keep = data.frame(predictor = c('SurveyYr', 'Age', 'AlcoholYear', 'Marijuana', 'SmokeNow', 
                                   'HardDrugs', 'BPDiaAve', 'BPSysAve', 'PhysActiveDays', 'TVHrsDay', 
                                   'CompHrsDay', 'TotChol', 'Diabetes', 'UrineVol1', 'HealthGen',
                                   'LittleInterest', 'Poverty', 'SleepHrsNight', 'Gender', 
                                   'Race1', 'Education', 'MaritalStatus' ))

opts <- options(knitr.kable.NA = "")
knitr::kable(list(df_keep[1:11,], df_keep[12:22,]), caption = "Initial Predictors Selected", 
             col.names = "Predictor", booktabs = TRUE)
```

Next, let's build a dataset `nhanes_select` using just the above `df_keep` variables.

Furthermore, the NHANES dataset has data for 2 survey years: 2009-10 and 2011-12. There are certain variables, such as TVHrsDay and CompHrsDay which are only present within the later time period (2011_2012). To eliminate this large missing value problem, we will further filter our dataset down by the more recent year, 2011_12.

```{r}
nhanes_select = subset(NHANES, select =c(df_keep$predictor, "BMI"))
nhanes_select = nhanes_select[nhanes_select$SurveyYr == '2011_12', ] #filtering by survey year
nhanes_select = subset(nhanes_select, select = -c(SurveyYr)) #removing SurveyYr as a column for 
#model building
```
The resulting dataset, after the initial variable selection and filtering above, consists of `r nrow(nhanes_select)` observations (rows) and `r ncol(nhanes_select)` variables (columns) including `BMI` and the chosen predictors.


**Convert Categorical Variables into Factor Variables**

We will now convert the categorical predictors into factors.

```{r}
nhanes_select$Marijuana = as.factor(nhanes_select$Marijuana)
nhanes_select$SmokeNow = as.factor(nhanes_select$SmokeNow)
nhanes_select$HardDrugs = as.factor(nhanes_select$HardDrugs)
nhanes_select$Diabetes = as.factor(nhanes_select$Diabetes)
nhanes_select$TVHrsDay = as.factor(nhanes_select$TVHrsDay)
nhanes_select$CompHrsDay = as.factor(nhanes_select$CompHrsDay)
nhanes_select$HealthGen = as.factor(nhanes_select$HealthGen)
nhanes_select$LittleInterest = as.factor(nhanes_select$LittleInterest)
nhanes_select$Gender = as.factor(nhanes_select$Gender)
nhanes_select$Race1 = as.factor(nhanes_select$Race1)
nhanes_select$Education = as.factor(nhanes_select$Education)
nhanes_select$MaritalStatus = as.factor(nhanes_select$MaritalStatus)
```

#### Address Missing Values

It would be helpful to have a dataset which is devoid of NAs (missing values) before we conduct our regression analysis. First let's get a quick idea of how many missing values are present in our initial dataset. 

**Identify which variables have majority Nan values**

```{r}
library(tidyverse, quiet = TRUE)

# Count the NA values in each column
na_counts = colSums(is.na(nhanes_select))

# Calculate the percentage of NA values in each column
total_rows = nrow(nhanes_select)
na_percentage = (na_counts / total_rows) * 100

# Create a dataframe to store the results
na_summary = data.frame(Column = names(na_counts), NA_Count = na_counts, NA_Percentage = na_percentage)
na_summary = na_summary %>%
  arrange(desc(NA_Percentage))

# Print the summary
print(na_summary)

```

The table above is sorted according to NA percentage in descending order. The top 5 predictors as far as NAs are concerned are: `SmokeNow`, `PhysActiveDays`, `Marijuana`, `HardDrugs` and `AlcoholYr`. Half of all predictors have greater than 25% missing values. If we eliminated all rows with any missing value, we would be left with only `r nrow(na.omit(nhanes_select))`, which is not enough observations to be meaningful. We cannot simply proceed using this data, as any regression tools we will use will need to eliminate many observations in order to proceed with the statistical calculations. It would also be inappropriate to simply eliminate these observations, although this was previously the standard approach. Eliminating this many observations would bring into question how well our study models represent the underlying population. Interpretation of our results would become more difficult, and suspicious of selective observation elimination introducing bias. This data was also costly to produce - we prefer to not simply cast it aside. We therefore decided to perform data imputation for the missing data. 

Data imputation involves the substitution of missing data with a different value. Although there are simple methods of replacing missing values with the mean or median of the variable in question, the most robust method is multiple imputation. Multiple imputation involves the generation of multiple complete datasets by replacing the missing values with data values which are modeled for each missing entry, from a plausible distribution. The imputation process can use a variety of methods for computing the imputed values, depending upon the underlying distribution of the observed values, and the relationship of those observed values and the other variables in the observation. Once the multiple complete datasets are generated, any analysis can be performed (such as linear regression) and the results of each analyses are pooled into one set of results.

We will perform the multiple imputation process with the `mice` package below. More information regarding the `mice` package can be read at the book website [Flexible Imputation of Missing Data](https://stefvanbuuren.name/fimd/)

### Data Imputation with the `mice` Package

```{r eval=FALSE}
if (!require(mice)) {
  install.packages("mice", quiet = TRUE)  
}
```

Here we will perform the imputation. Given the size of the data, this will take a bit of processing time.
First we will remove the observations where there is no entry for BMI as there are only `r sum(is.na(nhanes_select$BMI))` such observations, to avoid imputation of our response variable. There are `r nrow(nhanes_select[!is.na(nhanes_select$BMI),])` observations left after this operation.  


```{r}
library(mice, quiet = TRUE)
# remove the rows which have NAs for BMI
nhanes_imp = nhanes_select[!is.na(nhanes_select$BMI), ]

# perform the multiple imputation (5 datasets)
imp = mice(nhanes_imp, seed = 420, m = 5, print = FALSE)

```

See Appendix for density plots comparing the imputed and observed values.

### Initial Model Building and Diagnostics

Now that imputation is complete to address the missing data, we will build a complete additive model using the variables we decided to keep earlier, to allow for an initial diagnostic evaluation.

```{r}
# perform the linear regression with each of the 5 imputed datasets
fit_add <- with(imp, lm(BMI ~  Age +  AlcoholYear + Marijuana + SmokeNow +
  HardDrugs + BPDiaAve + BPSysAve + PhysActiveDays + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Gender +  Race1 +  Education +  MaritalStatus))

summary(fit_add$analyses[[1]]) #summary of the model with the 1st imputed dataset
```

We will next construct a dataframe of all of our 5 imputed datasets, with the additional values
added of columns `.imp` for the imputation number, and `.i` for the observation number within that imputation.

```{r}
imp_df = mice::complete(imp, action = "long")
```

#### Collinearity

When we built the additive model above, a few parameters had large p-values. Let's check the variance inflation factors for all the predictors in this model, to see if there is any effect of collinearity on the variance of our regression estimates.  

```{r}
library(car, quiet = TRUE)
car::vif(fit_add$analyses[[1]])
```

None of the variable appear to have a large (>5) variance inflation factor which is good to see.  

#### Variance and Normality Assessment

Now let's do some diagnostic tests on this model to identify any potential issues.

```{r}
library(lmtest)

### First, let's define some functions ###

# Function to calculate the LOOCVRMSE
calc_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

# model diagnostics
model_diagnostics = function(fit){
  fit_summary <- data.frame(bptest_p = rep(0,5), shapirotest_p = rep(0,5))
  for (i in 1:5){
    fit_summary$bptest_p[i] = unname(bptest(fit$analyses[[i]])$p.value)
    fit_summary$shapirotest_p[i] = shapiro.test(residuals(fit$analyses[[i]]))$p.value 
  }
  knitr::kable(fit_summary, col.names = c("BP Test", "Shapiro Test"))
}

 
# model assessments
model_assess = function(fit){
  fit_summary <- data.frame(adj_r_squared = rep(0,5), loocv_rmse = rep(0,5))
  for (i in 1:5){
    fit_summary$adj_r_squared[i] = summary(fit$analyses[[i]])$adj
    fit_summary$loocv_rmse[i] = calc_loocv_rmse(fit$analyses[[i]]) 
  }
  knitr::kable(fit_summary, col.names = c("Adj. R-Squared", "LOOCV-RMSE"))
}
```

```{r, fig.asp=1}
par(mfrow = c(2,3))
#Fitted versus Residuals Plot for the imputed dataset model
for (i in seq(1,5)) {
  title = strwrap(paste("Fitted versus Residuals Plot using dataset ", as.character(i)), width = 30, simplify = FALSE)
  plot(fitted(fit_add$analyses[[i]]), resid(fit_add$analyses[[1]]), col = "darkblue", pch = 20,
       xlab = "Fitted", ylab = "Residuals", main = title)
  abline(h=0,col = "darkorange")  
}
```

The Fitted versus Residuals plot reveals deviation from homoscedasticity (constant variance). 

```{r, fig.asp=1}
#Normal Q-Q Plot for the 1st imputed dataset model
qqnorm(resid(fit_add$analyses[[1]]), col = "dodgerblue")
qqline(resid(fit_add$analyses[[1]]), col = "darkorange")
```

The Q-Q-Plot also shows deviations from normality. 

Let's now look at the p-values from the Shapiro-Wilk Test for normality, and the Breusch-Pagan Test for Homoscedasticity.

```{r}
model_diagnostics(fit_add)
```
The p-values for these tests, using each of the 5 imputed dataset models, are all very low, essentially 0. So we reject the null hypothesis, calling into question, both normality and homoscedasticity. However, both of these tests are susceptible to the influence of large sample sizes, so they may be less reliable in this setting.

Because of the findings above, we will perform a variance stabilizing log transformation on the response variable (BMI), fit the model again and reassess the diagnostics.

```{r}
# perform the linear regression with each of the 5 imputed datasets
# and the log() transform of BMI
fit_add_log <- with(imp, lm(log(BMI) ~  Age +  AlcoholYear + Marijuana + SmokeNow +
  HardDrugs + BPDiaAve + BPSysAve + PhysActiveDays + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Gender +  Race1 +  Education +  MaritalStatus))

summary(fit_add_log$analyses[[1]]) #summary of the model with the 1st imputed dataset
```

```{r, fig.asp=1}
#Comparing the Fitted versus Residuals Plots of the Initial Additive model and the Log(BMI) #Transformation Model
par(mfrow=c(1,2))
plot(fitted(fit_add$analyses[[1]]), resid(fit_add$analyses[[1]]), col = "darkblue", pch = 20,
     xlab = "Fitted", ylab = "Residuals", main = "Fitted vs Residuals - BMI")
abline(h=0,col = "darkorange")
plot(fitted(fit_add_log$analyses[[1]]), resid(fit_add_log$analyses[[1]]), col = "darkblue", pch = 20,
     xlab = "Fitted", ylab = "Residuals", main = "Fitted vs Residuals - log(BMI)")
abline(h=0,col = "darkorange")
```
The log transformation of BMI model looks much better, though still not perfect. 

Now let's look at the Q-Q plots:

```{r, fig.asp=1}
#Comparing the Normal Q-Q Plots of the Initial Additive model and the Log(BMI) Transformation Model
par(mfrow=c(1,2))
# no transformation
qqnorm(resid(fit_add$analyses[[1]]), col = "dodgerblue", main = "Normal Q-Q Plot - BMI")
qqline(resid(fit_add$analyses[[1]]), col = "darkorange")
# log transformation
qqnorm(resid(fit_add_log$analyses[[1]]), col = "dodgerblue", main = "Normal Q-Q Plot - log(BMI)")
qqline(resid(fit_add_log$analyses[[1]]), col = "darkorange")
```

Again, the log transformation of BMI results is a much better appearing QQ plot. Moving forward, we will use the log transformed BMI for our model building.


#### Model Search for Selection

Now we use the different search procedures, backwards, forwards, and stepwise to search for models and select predictors. Notice that our 5 datasets with observed and imputed data are passed to the stepwise function using `with()` which in this case returns a `mira` object from the `mice` package.

First we will start with the additive model and perform a backward AIC model search.
```{r}
# build the stepwise workflow
scope <- list(upper = ~ Age +  AlcoholYear + Marijuana + SmokeNow +
  HardDrugs + BPDiaAve + BPSysAve + PhysActiveDays + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Gender +  Race1 +  Education +  MaritalStatus,
             lower = ~ 1)
expr <- expression(f1 <- lm(log(BMI) ~ 1),
                  f2 <- step(f1, scope = scope, trace = 0))
# perform the stepwise selection with each of the 5 imputed datasets
fit <- with(imp, expr)

# count the votes for variables to keep
formulas <- lapply(fit$analyses, formula)
terms <- lapply(formulas, terms)
votes <- unlist(lapply(terms, labels))
table(votes)
```

If we use the criterion of more than half of the datasets resulted in selection of a variable, we end up only dropping Education, Gender, and Marijuana. Let's compare the models using anova, leaving out variables with less than 5 votes.

```{r}
# remove HardDrugs
model_without = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + PhysActiveDays + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Race1  +  MaritalStatus))
model_with = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  HardDrugs + BPDiaAve + BPSysAve + PhysActiveDays + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Race1  +  MaritalStatus))
anova(model_without, model_with)
```

This p-value is not significant, so we fail to reject the null hypothesis and we can discard `HardDrugs`.

```{r}
# remove PhysActiveDays
model_without = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Race1  +  MaritalStatus))
model_with = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + PhysActiveDays + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Race1  +  MaritalStatus))
anova(model_without, model_with)
```

Again, we fail to reject the null hypothesis based on the p-value, and can remove `PhysActiveDays`.

```{r}
# remove Poverty
model_without = with(imp, lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus))
model_with = with(imp, lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Race1  +  MaritalStatus))
anova(model_without, model_with)
```

This p-value is again greater than 0.05, and so we will remove `Poverty` for now. 

Here is the final model of this process which we will call `fit_add_aic`

```{r}
fit_add_aic = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus))
summary(fit_add_aic$analyses[[1]])$r.squared

```
Let's try a forward search using BIC, and see if we get a smaller model:

```{r}
# build the stepwise workflow, full scope with all predictors
scope <- list(upper = ~ Age +  AlcoholYear + Marijuana + SmokeNow +
  HardDrugs + BPDiaAve + BPSysAve + PhysActiveDays + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Gender +  Race1 +  Education +  MaritalStatus,
             lower = ~ 1)
expr <- expression(f1 <- lm(log(BMI) ~ 1),
                  f2 <- step(f1, scope = scope, direction = "forward", 
                             K = log(nrow(imp[["data"]])), trace = 0))
# perform the stepwise selection with each of the 5 imputed datasets
fit <- with(imp, expr)

# count the votes for variables to keep
formulas <- lapply(fit$analyses, formula)
terms <- lapply(formulas, terms)
votes <- unlist(lapply(terms, labels))
table(votes)

```

This appears to yield the same votes as the prior method, which results in the same model.

Lastly, let's try a Stepwise search in both directions using AIC.

```{r}
# build the stepwise workflow
scope <- list(upper = ~ Age +  AlcoholYear + Marijuana + SmokeNow +
  HardDrugs + BPDiaAve + BPSysAve + PhysActiveDays + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest + Poverty +
  SleepHrsNight +  Gender +  Race1 +  Education +  MaritalStatus,
             lower = ~ 1)
expr <- expression(f1 <- lm(log(BMI) ~ 1),
                  f2 <- step(f1, scope = scope, direction = "both", 
                             trace = 0))
# perform the stepwise selection with each of the 5 imputed datasets
fit <- with(imp, expr)

# count the votes for variables to keep
formulas <- lapply(fit$analyses, formula)
terms <- lapply(formulas, terms)
votes <- unlist(lapply(terms, labels))
table(votes)
```

Here agin we get the same results. For now, our additive model will be `fit_add_aic`

Before we move on, there are some predictors which are not significant individually as we saw from the summary of the model earlier, so we should check for collinearity again.


```{r}
car::vif(fit_add_aic$analyses[[1]])
```

There appear to be no major issues with collinearity in this additive model.

#### Further Predictor Exploration 

Additionally, we want to check which variables from this addditive model are correlated with BMI to further investigate possible interaction terms, and determine if there are additional variables we could consider dropping.  

```{r}
library("corrplot")

# Subset the 'nhanes' dataset using the names of numerical columns in 'numerical_data'
nhanes_numerical_subset = nhanes_select[, c('Age', 'AlcoholYear', 'BPDiaAve', 'BPSysAve', 'UrineVol1',
                                            'SleepHrsNight', 'TotChol' ,'BMI')]  

# Calculate the correlation matrix for 'nhanes_numerical_subset'
cor_matrix  = cor(nhanes_numerical_subset, use = "complete.obs")

# Create the correlation plot for 'BMI' and other numeric variables
corrplot(cor_matrix, type = "upper", tl.cex = 0.8, tl.col = "black", tl.srt = 45)

```


```{r}

if (!require(vcd)) {
  install.packages("vcd", quiet = TRUE)  
}

library(vcd)

# Subset the 'nhanes' dataset using the names of categorical columns in 'categorical_data'
nhanes_categorical_subset = nhanes_select[, c('SmokeNow', 'TVHrsDay', 'CompHrsDay','Diabetes',
                                              'HealthGen', 'LittleInterest', 'Race1', 
                                              'MaritalStatus', 'BMI')]   

# Assuming 'nhanes_categorical_subset' already contains the 'BMI' column and categorical variables

# Perform a Chi-square test for each categorical variable
for (var in names(nhanes_categorical_subset)) {
  if (is.factor(nhanes_categorical_subset[[var]])) {
    chi_result <- chisq.test(nhanes_categorical_subset[[var]], nhanes_categorical_subset$BMI)
    print(paste("Variable:", var))
    print(chi_result)
  }
}

```
Since all the p-values for the categorical values above are very small, we do not sneed to remove them. 
However, based upon the findings of the numerical data above, it seems reasonable to try removing both `UrineVol1` and `TotChol`, as their individual correlations with BMI are negligible.

First we will try removing `UrineVol1` at a significance level $\alpha = 0.01$:

```{r}
fit_add_aic_with = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  UrineVol1 +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus))
# removing UrineVol1 
fit_add_aic_without =with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus))
anova(fit_add_aic_without, fit_add_aic_with)
```

Since the p-value of the anova test comparing the models with and without `UrineVol` is greater than 0.01, we fail to reject the null hypothesis, and should remove the variable.

Now let's consider removing `TotChol` at a significance level $\alpha = 0.01$.

```{r}
fit_add_aic_with = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus))
# removing TotChol
fit_add_aic_without =with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus))
anova(fit_add_aic_without, fit_add_aic_with)
```

Likewise, the p-value is greater than 0.01, although it is less than 0.05, so for now we can leave it.

So our **final simple additive model** is below, and we will name it `final_add`.

```{r}
final_add = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus))
summary(final_add$analyses[[1]])
```


#### Data Interactions


To determine if interaction terms might improve our model, we will perform a backward AIC stepwise() function with added `Age` interaction terms. This seemed the most plausible and made the most sense from a domain perspective. It could be understandable for instance, that alcohol use at a young age vs an older age might have combined effects upon BMI.


```{r}
# build the stepwise workflow using our fit_add_aic 
# with interaction terms added as a starting point
scope <- list(upper = ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  TotChol +  Diabetes + HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus +  Age:AlcoholYear +  Age:SmokeNow +  Age:BPDiaAve +  
    Age:BPSysAve  + Age:TVHrsDay + Age:CompHrsDay +  Age:TotChol +  Age:Diabetes +  Age:HealthGen +
    Age:LittleInterest +  Age:SleepHrsNight +  Age:Race1 +  Age:MaritalStatus,
             lower = ~ 1)
expr <- expression(f1 <- lm(log(BMI) ~ 1),
                  f2 <- step(f1, scope = scope, trace = 0))
# perform the stepwise selection with each of the 5 imputed datasets
fit <- with(imp, expr)

# count the votes for variables to keep
formulas <- lapply(fit$analyses, formula)
terms <- lapply(formulas, terms)
votes <- unlist(lapply(terms, labels))
table(votes)

```

We now build a model with all the above predictors with > 3 votes.

```{r}
fit_int_aic = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus +  Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve
  + Age:TVHrsDay  +  Age:Diabetes +   Age:HealthGen +  Age:Race1 +  Age:MaritalStatus))
summary(fit_int_aic$analyses[[1]])
```

We conduct an anova test to check if we should keep `Age:TVHrsDay` or not as the individual p-values are not significant.

```{r}

fit_int_aic_with = with(imp, lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus +  Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve  
  + Age:TVHrsDay  +  Age:Diabetes +   Age:HealthGen +  Age:Race1 +  Age:MaritalStatus))

# removing Age:TVHrsDay
fit_int_aic_without =with(imp, lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus +  Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve
  +  Age:Diabetes +   Age:HealthGen +  Age:Race1 +  Age:MaritalStatus))
anova(fit_int_aic_without, fit_int_aic_with)
```

The p-value is less than 0.05, so for now, we will keep `Age:TVHrsDay`.

We also notice from the model that the the p-values for `Race1` categories and their interaction terms are not significant, and the estimates are low. Perhaps we can remove Race1, and the interaction term.

```{r}
fit_int_aic_with = with(imp, lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus +  Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve
  + Age:TVHrsDay  +  Age:Diabetes +   Age:HealthGen +  Age:Race1 +  Age:MaritalStatus))

# removing Age:Race1 and interaction
fit_int_aic_without =with(imp, lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  MaritalStatus +  Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve
  +  Age:Diabetes +   Age:HealthGen +  Age:MaritalStatus))
anova(fit_int_aic_without, fit_int_aic_with)
```

The p-value is very low, less than 0.01, so we reject the null hypothesis, and will keep `Race1` and the related interaction term.

So our final model with the addition of interactions is `final_int`, and is given below:

```{r}
final_int = with(imp, lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow +
  BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus +  Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve  
  + Age:TVHrsDay  +  Age:Diabetes +   Age:HealthGen +  Age:Race1 +  Age:MaritalStatus))
summary(final_int$analyses[[1]])
```

#### Data Transformations

Now we will consider if our model will benefit from any data transformations. The two numerical variables we are most suspicious of having skewed distributions are those related to blood pressure. Let's graph each of their distributions. We are using the imputed data, but only one of the 5 imputed datasets.

BPSysAve Transformation:

```{r}
par(mfrow=c(1,2))
hist(imp_df[imp_df$.imp == 1, ]$BPSysAve,
     main = "Histogram - BPSysAve",
     xlab = "BPSysAve")
hist(log(imp_df[imp_df$.imp == 1, ]$BPSysAve),
     main = "Histogram - Log(BPSysAve)",
     xlab = "Log(BPSysAve)")
```

We notice that the non-transformed `BPSysAve` data appears skewed right, so we apply a log transformation, and the distribution improves.

BPDiasAve Trnasformation:

```{r}
par(mfrow=c(1,2))
hist(imp_df[imp_df$.imp == 1, ]$BPDiaAve,
     main = "Histogram - BPDiaAve",
     xlab = "BPDiaAve")
hist((imp_df[imp_df$.imp == 1, ]$BPDiaAve)^2,
     main = "Histogram - BPDiaAve^2",
     xlab = "BPDiaAve^2")
```

In the case of `BPDiaAve`, we notice that the non-transformed data appeared skewed left, so we apply a log transformation, and the distribution improves somewhat, though it is a bit right skewed, but less skewed overall.

Now we will consider our model with the log transformed BP measures:


```{r}
final_trns = with(imp, lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
  I(BPDiaAve^2) + log1p(BPSysAve) + TVHrsDay + CompHrsDay +
  Diabetes +  HealthGen +  LittleInterest +
  SleepHrsNight +  Race1  +  MaritalStatus +  Age:SmokeNow +  Age:I(BPDiaAve^2) +  
    Age:log1p(BPSysAve)  + Age:TVHrsDay +  Age:Diabetes +  Age:HealthGen +  Age:Race1 +  
    Age:MaritalStatus))

#Note: we apply log1p to get the natural log of (1+BPSysAve), as we were getting infinity
#for 0 and NaN for negative values of BPSysAve with log(BPSysAve)

summary(final_trns$analyses[[1]])
```
We notice that our R-Squared is the same as without the transformed data, but this will represent our final transformation model and we will more fully compare all three models in the next section.

#### Final Models

Based on our analysis, these are the final 3 models that we will conduct further outlier and diagnostic assessments on:

*Additive Model*
log(BMI) ~ Age +  AlcoholYear + SmokeNow + BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay + TotChol +  Diabetes + HealthGen +  LittleInterest + SleepHrsNight +  Race1  +  MaritalStatus

*Model with Interactions*
log(BMI) ~  Age +  AlcoholYear + SmokeNow + BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay + Diabetes +  HealthGen + LittleInterest + SleepHrsNight +  Race1  +  MaritalStatus + Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve  + Age:TVHrsDay + Age:Diabetes +   Age:HealthGen +  Age:Race1 +  Age:MaritalStatus


*Model with Transformation & Interactions*
log(BMI) ~ Age +  AlcoholYear + SmokeNow + I(BPDiaAve^2) + log1p(BPSysAve) + TVHrsDay + CompHrsDay + Diabetes + HealthGen +  LittleInterest + SleepHrsNight +  Race1  + MaritalStatus +  Age:SmokeNow +  Age:I(BPDiaAve^2) + Age:log1p(BPSysAve)  + Age:TVHrsDay +  Age:Diabetes + Age:HealthGen +  Age:Race1 +  Age:MaritalStatus

We arrived at these models using the following steps:
1. Ruled out many variables by grouping them into similar domains and keeping only one representative variable in case we detected collinearity. This reduced the number of possible predictors from `r ncol(NHANES)-1` to `r ncol(nhanes_select)-1`.
2. Dealt with missing data using multiple imputation using the `mice` package. 
3. Fitted a first version of an additive model with the selected predictors and detected violations of equal variance and normality. 
4. Log-transformed the response in an attempt to alleviate the constant variance violation.
5. Performed AIC and BIC stepwise processes and conducted anova tests to reduce the number of predictors further.
6. Tested interaction of `Age` with other predictors as well as transformations of `BPDiaAve`, `BPSysAve`. 

## Results

#### Outlier Assessment

For each of the 3 models, we would  now like to see if there are any outliers that are influential, and that are having a large effect on our regressions. We will conduct this assessment using Cook's Distance. 

```{r}
#finding influential observations for each model

indexs_trns = which(cooks.distance(final_trns$analyses[[1]]) > 4 / 
                      length(cooks.distance(final_trns$analyses[[1]])))

indexs_int = which(cooks.distance(final_int$analyses[[1]]) > 4 / 
                     length(cooks.distance(final_int$analyses[[1]])))

indexs_add = which(cooks.distance(final_add$analyses[[1]]) > 4 / 
                     length(cooks.distance(final_add$analyses[[1]])))


#removing influential observations for each model using the first imputed dataset

imp_df_1 = imp_df[imp_df$.imp == 1, ]
imp_df_1_trns_rm = imp_df_1[-indexs_trns, ]
imp_df_1_int_rm = imp_df_1[-indexs_int, ]
imp_df_1_add_rm = imp_df_1[-indexs_add, ]
```

Next, we will fit the 3 models afer removing the influential observations.

```{r}
#Final_add Model fit with influential observations removed

final_add = lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
                 BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
                 TotChol +  Diabetes +  HealthGen +  LittleInterest +
                 SleepHrsNight +  Race1  +  MaritalStatus, data = imp_df_1_add_rm)
```

```{r}
#Final_int Model fit with influential observations removed

final_int = lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow + BPDiaAve + BPSysAve +
                 TVHrsDay + CompHrsDay + Diabetes +  HealthGen +  
                 LittleInterest + SleepHrsNight +  Race1  +  MaritalStatus +  
                 Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve  + Age:TVHrsDay +
                 Age:Diabetes +   Age:HealthGen +  Age:Race1 +  Age:MaritalStatus,
               data = imp_df_1_int_rm)

```

```{r}
#Final_trns Model fit with influential observations removed 

final_trns = lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow + I(BPDiaAve^2) +
                  log1p(BPSysAve) + TVHrsDay + CompHrsDay + Diabetes +  
                  HealthGen +  LittleInterest + SleepHrsNight +  Race1  +
                  MaritalStatus +  Age:SmokeNow +  Age:I(BPDiaAve^2) +
                  Age:log1p(BPSysAve)  + Age:TVHrsDay +  Age:Diabetes +
                  Age:HealthGen +  Age:Race1 +  Age:MaritalStatus, 
                data = imp_df_1_trns_rm)
```


### Model Diagnostics

Now that we have removed the influential observations, we would like to conduct different diagnostic tests and see how the 3 models perform. 

Diagnostic Tests

```{r}
#Functions to calculate various diagnostics
get_adj_r2 = function(model) {
  summary(model)$adj.r.squared
}

calc_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

get_shapiro = function(model) {
  shapiro.test(resid(model))$p.value
}

get_bp = function(model) {
  unname(bptest(model)$p.value)
}
```


```{r}
# model comparison results
row_names = c("Additive Model", "Model with Interactions", "Model with Transformations")
col_names = c("Model", "BP Test", "Shapiro-Wilk Test", "Adjusted R2")

bp_results = c(get_bp(final_add), get_bp(final_int), get_bp(final_trns))
shapiro_results = c(get_shapiro(final_add), get_shapiro(final_int), get_shapiro(final_trns))
r2_results = c(get_adj_r2(final_add), get_adj_r2(final_int), get_adj_r2(final_trns))

results_table = cbind(row_names, signif(bp_results,6), signif(shapiro_results,6), round(r2_results,6))
knitr::kable(results_table, col.names = col_names, caption = "Model Comparison")

```

As we see from the table above, we have been able to build 3 models which can explain more than 49% of the variability in the dataset, according to adjusted $R^2$.
As far as adjusted $R^2$ is concerned, the interaction model and the transformed model perform better than the additive model, by explaining about 7.5% more of the variability. All models have issues with heteroskedasticity and violation of normality assumptions according to the Breusch-Pagan and Shapiro-Wilk tests, respectively. 

Next, we'll split the data into testing and training sets to see how these 3 models compare when we evaluate the LOOCV-RMSE on the training (unseen) data. 

```{r}
set.seed(420)
#Splitting the data for the Final_add Model
add_idx  = sample(nrow(imp_df_1_add_rm), size = trunc(0.80 * nrow(imp_df_1_add_rm)))
add_trn_data = imp_df_1_add_rm[add_idx, ]
add_tst_data = imp_df_1_add_rm[-add_idx, ]

#Splitting the data for the Final_int Model
int_idx  = sample(nrow(imp_df_1_int_rm), size = trunc(0.80 * nrow(imp_df_1_int_rm)))
int_trn_data = imp_df_1_int_rm[int_idx, ]
int_tst_data = imp_df_1_int_rm[-int_idx, ]

#Splitting the data for the Final_trns Model
trns_idx  = sample(nrow(imp_df_1_trns_rm), size = trunc(0.80 * nrow(imp_df_1_trns_rm)))
trns_trn_data = imp_df_1_trns_rm[trns_idx, ]
trns_tst_data = imp_df_1_trns_rm[-trns_idx, ]
```

We will re-fit the models using the training data.

```{r}
#Final_add Model fit with influential observations removed, and using training data

final_add2 = lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow +
                 BPDiaAve + BPSysAve + TVHrsDay + CompHrsDay +
                 TotChol +  Diabetes +  HealthGen +  LittleInterest +
                 SleepHrsNight +  Race1  +  MaritalStatus, data = add_trn_data)
```

```{r}
#Final_int Model fit with influential observations removed, and using training data

final_int2 = lm(log(BMI) ~  Age +  AlcoholYear + SmokeNow + BPDiaAve + BPSysAve +
                 TVHrsDay + CompHrsDay + Diabetes +  HealthGen +  
                 LittleInterest + SleepHrsNight +  Race1  +  MaritalStatus +  
                 Age:SmokeNow +  Age:BPDiaAve +  Age:BPSysAve  + Age:TVHrsDay +
                 Age:Diabetes +   Age:HealthGen +  Age:Race1 +  Age:MaritalStatus,
               data = int_trn_data)

```


```{r}
#Final_add Model fit with influential observations removed, and using training data

final_trns2 = lm(log(BMI) ~ Age +  AlcoholYear + SmokeNow + I(BPDiaAve^2) +
                  log1p(BPSysAve) + TVHrsDay + CompHrsDay + Diabetes +  
                  HealthGen +  LittleInterest + SleepHrsNight +  Race1  +
                  MaritalStatus +  Age:SmokeNow +  Age:I(BPDiaAve^2) +
                  Age:log1p(BPSysAve)  + Age:TVHrsDay +  Age:Diabetes +
                  Age:HealthGen +  Age:Race1 +  Age:MaritalStatus, 
                data = trns_trn_data)
```

```{r}
# model comparison results
row_names = c("Additive Model", "Model with Interactions", "Model with Transformations")
col_names = c("Model", "LOOCV_RMSE", "Avg Pct Error")


predicted_add2 = exp(predict(final_add2, newdata = add_tst_data))
avg_pct_error_add2 = mean(abs(predicted_add2 - add_tst_data$BMI)
                     /predicted_add2) * 100 

predicted_int2 = exp(predict(final_int2, newdata = int_tst_data))
avg_pct_error_int2 = mean(abs(predicted_int2 - int_tst_data$BMI)
                     /predicted_int2) * 100 

predicted_trns2 = exp(predict(final_trns2, newdata = trns_tst_data))
avg_pct_error_trns2 = mean(abs(predicted_trns2 - trns_tst_data$BMI)
                     /predicted_trns2) * 100 

rmse_results2 = c(calc_loocv_rmse(final_add2), calc_loocv_rmse(final_int2), calc_loocv_rmse(final_trns2))
avg_pct_error2 = c(avg_pct_error_add2, avg_pct_error_int2, avg_pct_error_trns2)

results_table2 = cbind(row_names, round(rmse_results2,6), round(avg_pct_error2,6))
knitr::kable(results_table2, col.names = col_names, caption = "Model Comparison")

```

We would like to select a model with the lowest value for LOOCV-RMSE, so it does not overfit or underfit, and well as has the lowest value for Average Percent Error so it is able to perform well while predicting *unseen* data. Based on the above results, although the model with transformations has the lowest values for these metrics, there is not a big difference when compared to the other 2 models, especially the model with interactions. 

Let's also look at the plots for the predicted versus the actual values for these 3 models and add the line $y = x$.

```{r}
par(mfrow=c(1,3))
plot(add_tst_data$BMI,
     predicted_add2, 
     col = "dodgerblue", 
     pch = 20,
     main = "Additive Model",
     xlab = "Actual",
     ylab = "Predicted"
     )
abline(a=0, b=1, col = "darkorange", lwd = 3)

plot(int_tst_data$BMI,
     predicted_int2, 
     col = "dodgerblue", 
     pch = 20,
     main = "Model with Interactions",
     xlab = "Actual",
     ylab = "Predicted"
     )
abline(a=0, b=1, col = "darkorange", lwd = 3)

plot(trns_tst_data$BMI,
     predicted_trns2, 
     col = "dodgerblue", 
     pch = 20,
     main = "Model with Transformations",
     xlab = "Actual",
     ylab = "Predicted"
     )
abline(a=0, b=1, col = "darkorange", lwd = 3)
```

We see that the Model with Transformations does better at predicting BMI, however, it does not differ that much from the Model with Interactions. The additive model does not perform as well as the other two models for predicting BMI. 

## Discussion

Based on our findings above, we feel that from a prediction and explainability point of view, we would prefer the interaction model, since the transformations do not seem to help much and the interaction model is a little simpler than the model with transformations. 


## Appendix

### Variable Selection

#### Additional `pairs()` Plots for Collinearity Assessment

Alcohol related variables:

```{r, fig.asp=1}
to_test = c("Alcohol12PlusYr", "AlcoholDay", "AlcoholYear")
pairs(subset(NHANES, select = to_test))
```

Smoking and Drug related variables:

```{r, fig.asp=1}
to_test = c("SmokeNow", "Smoke100", "SmokeAge", "Marijuana", "RegularMarij", "AgeRegMarij", "HardDrugs")
pairs(subset(NHANES, select = to_test))

```

Lifestyle related variables:

```{r, fig.asp=1}
to_test = c("PhysActive", "PhysActiveDays", "TVHrsDay", "CompHrsDay", "TVHrsDayChild", "CompHrsDayChild")
pairs(subset(NHANES, select=to_test))
```

Cholesterol related variables:

```{r, fig.asp=1}
to_test = c("DirectChol", "TotChol", "Diabetes", "DiabetesAge")
pairs(subset(NHANES, select = to_test))
```

Urine related variables:

```{r, fig.asp=1}
to_test = c("UrineVol1", "UrineFlow1", "UrineVol2", "UrineFlow2")
pairs(subset(NHANES, select = to_test))
```

Mental health related variables:

```{r, fig.asp=1}
to_test = c("HealthGen", "DaysPhysHlthBad", "DaysMentHlthBad", "LittleInterest", "Depressed" )
pairs(subset(NHANES, select = to_test))
```

#### Data Imputation

```{r}
# Compare the imputed variables (red) and observed (blue)
densityplot(imp)
# summary(imp)
```

